<div style="text-align: justify">

# Malware Lab with Internet Access (libvirt)
## Setting up the virtual networks 
The main idea behind this setup is that, given that most malware nowadays has at least limited need for connectivity (be it for downloading subsequent stages or in order to communicate with C2), we would like to have a fully virtualized home lab for analysis which is able to provide malware with access to the internet while still:  

1. Being isolated from the home network.
2. Preventing the bad guys from learning the public IP associated with our home network.

We will try to achieve this by leveraging a pfSense appliance doubling up as a firewall and a TOR gateway. Furthermore, we will place an analysis machine acting as a router in between the pfSense and the victim network: thanks to this privileged position, this machine will be able not only to observe the traffic going in and out of the victim network, but also to potentially meddle with it as a good old MitM.  

**N.B.:** TOR can only be used as a tunnel for TCP traffic; this means that one will have to sacrifice either the possibility of analyzing UDP traffic or the protection provided by TOR when UDP traffic is let through the firewall. An alternative to TOR which still protects our real IP without having the (many) downsides of the former would be using a good VPN; while there are several VPN products available, we will mention only NordVPN, since it is efficient, well-known and quite cheap.

The network setup we want to achieve is shown in the following diagram:

<p align="center">
	<img src="images/malware_lab_network.png">
</p>

The first step consists in preparing the virtualized networks we will need our virtual devices to connect to. In `libvirt`, virtual networks are represented by constructs which are called *virtual network switches* and correspond to *virtual bridge interfaces* on the host system. The `default` network, which typically corresponds to virtual bridge `virbr0`, comes preconfigured and allows connectivity to the host and the internet. As per the diagram, we need to define two additional networks, which we will call `pfsense-net` and `victim-net`. Since we need to have strict control on the traffic, which means that all traffic in the 10.0.0.0/8 segment must pass through both the analysis machine and the pfSense appliance, we will define two virtual switches (one for each network) corresponding to virtual bridges which have no IP address and as such no association with a physical network interface. We will therefore create two files, one called `pfsense-net.xml` and the other `victim-net.xml`, which will represent each a switch object within `libvirt` with the following minimal configuration:  
```xml
<network>
  <name><net_name></name>
  <bridge name="<bridge_name>"/>
</network>
```
Where `<net_name>` is the name which is used to manage the network from the command line with `virsh`. On the host, the virtual network switch will be seen as a virtual bridge interface with name `<bridge_name>` and without an assigned IP.  

Once created, the two files can be used to define the corresponding networks with the command `virsh net-define <file_name>`. After having been defined, a network can be started with `virsh net-start <net_name>`; it is even possible to require the network to be started automatically at boot with `virsh net-autostart <net_name>`. 

Notice that typically `libvirt` allows to define a DHCP server on the virtual switch in order to distribute IPs to the machines on the network, but this is not possible without having an IP assigned to the bridge interface. Since we cannot allow this and our network is actually very small, in our case statically assigning IPs to the interfaces on the 10.0.0.0/8 network will be more than enough. 

## Setting up pfSense
The first virtual machine that we are going to set up will be our pfSense appliance. After [downloading the installation image](https://www.pfsense.org/download/), the following steps have to be performed:  

1. Create the disk image where the system will be installed: 
   ```bash
   qemu-img create -f qcow2 <hd_img> <size>
   ```
   This command will create the empty `.qcow2` image `<hd_img>` with the specified value of `<size>`. The size can be expressed in human-readable terms, e.g. "20G" to request a size of 20 Gigabytes (which should be enough in this case). Notice that using the `qcow2` format is necessary in order to make use of `libvirt`'s "internal snapshots"; if one is willing to adapt to using only "external snapshots", one can also specify the `raw` format instead for improved efficiency. More information about snapshots in `libvirt` can be found at the end of this section (step 12).  
2. Create the VM with the `virt-install` command; an example:
   ```bash
   virt-install \
   --name pfsense \
   --memory 1024 \
   --disk <install_img>,device=cdrom,boot_order=1 \
   --disk <hd_img>,bus=virtio,boot_order=2 \
   --network network=default,model=virtio \
   --network network=pfsense-net,model=virtio \
   --boot cdrom \
   --input mouse \
   --input keyboard \
   --graphics spice,mouse_mode=server,clipboard_copypaste=no,filetransfer_enable=no
   ```
   This example creates a VM with name `pfsense` with 1G RAM and two network interfaces, the first one attached to the `default` virtual network (it will be the WAN interface of our pfSense appliance) and the other attached to the `pfsense-net` network (it will be the LAN interface). The first `--disk` is the installation image file `<install_img>` (notice the `device` parameter set to `cdrom`), while the second is the disk image `<hd_img>` we created in the previous step. The `boot_order` parameter of `--disk` is, quite obviously, the boot order of the corresponding disk in the system. This is not necessary, but it will be useful since it will allow the system to boot immediately from the hard drive once the installation image will have been ejected without further headaches. The `--boot` option specifies the device used for installation (the `cdrom` in this case). Finally, the other options are once more not strictly necessary and can be removed if one prefers so; they are there simply in order to provide an additional degree of distance between the guest and the host, by disabling automatic mouse grab, clipboard sharing and file transfer between the two (it seems like automatic mouse grab is associated for some reason with the presence of a `tablet` input device, which is on by default; `mouse` and `keyboard` devices are therefore explicitly defined here in order to prevent it from being added to the system).
3. Follow the pfSense installation procedure; when prompted, select `Auto (UFS) BIOS` as partition method.
4. After the installation has been completed, a prompt will ask you whether you want to open a shell; don't do anything and open a terminal on the host instead.
5. On the host, execute the command `virsh shutdown pfsense` in order to gracefully terminate the VM, then once the VM has been successfully shut down launch the command `virsh change-media pfsense <cdrom_dev> --eject`, where `<cdrom_dev>` is the name of the cdrom device used for the installation media. There is more than one way to obtain this name; since we want to look very 1337, we will do it in the less obvious manner, by running the command `virsh dumpxml pfsense | grep -A 10 cdrom`, which should return something similar to the following:
   ```xml
   <disk type='file' device='cdrom'>
      <driver name='qemu' type='raw'/>
      <source file='<install_img>' index='2'/>
      <backingStore/>
      <target dev='<cdrom_dev>' bus='ide'/>
      <readonly/>
      <boot order='1'/>
      <alias name='ide0-0-0'/>
      <address type='drive' controller='0' bus='0' target='0' unit='0'/>
    </disk>
   ```
   The value of our interest is the `dev` parameter of the `target` tag.
6. After removing the `cdrom` device, bring the VM back up with the command `virsh start pfsense && remote-viewer spice://localhost:5900 &`. The second part of the command leverages the tool `remote-viewer` (which can be easily installed via `apt`) in order to retrieve the virtual device's display over the SPICE protocol. Which port to use depends on how many displays have already been opened this way, starting with 5900 as a default and increasing by 1 for each spice connection already active (if we had another display on already we would need to use port 5901 for this one).
7. When prompted about setting up VLANs, reply with `n` for "no".
8. Enter the WAN interface name; this one is a bit tricky, because we need to select the interface which is attached to the `default` network (it will be the one with direct access to the Internet) but pfSense seems to assign two default names, `vtnet0` and `vtnet1`, which do not correspond to the names of the interfaces we would find with `virsh dumpxml pfsense`. In order to be 100% sure we are picking the correct one, look at the MAC addresses of the two interfaces shown by pfSense below the line "Valid interfaces are:" and compare them with the results of the command `virsh dumpxml pfsense | grep -A 7 "<interface"`. Once the two interface names have been associated with the corresponding interfaces thanks to their MAC addresses, the name of the network each interface is attached to can be found in the `network` parameter of the `source` tag.
9. Enter the name of the LAN interface; of course this will depend on the result of the previous step, if the WAN interface was `vtnet0` then the LAN interface will be `vtnet1` or vice-versa.
10. When asked if you want to proceed, select `y` for "yes". The appliance will complete its setup and show its main menu.
11. Now we need to change the IP address of the LAN interface (the WAN interface should have one assigned by DHCP). Enter "2" to edit the IP addresses of the interfaces, then "2" again to select the LAN interface. Enter the new IPv4 address to be assigned to the interface, in our case "10.0.0.1" as per the diagram, then the subnet mask associated with it, which in our case will be "30" since the interface is going to be located on a transit network shared with our analysis machine. For the next two questions, press `Enter`, and press `n` when asked whether to enable DHCP on the LAN. Press `n` also for the next question.
12. The pfSense has been successfully set up! Of course we still need to configure it, but before doing that we will set up the analysis machine and a Windows 10 machine which will be our first "victim" machine. Nevertheless, this is a good moment to <u>take a snapshot of the VM</u>. There are two types of snapshots which can be created:  
    + "Internal snapshots" are the easiest ones to use since they have full support from `libvirt`; we can create an internal snapshot for our VM via the command `virsh snapshot-create-as --domain pfsense --name <snapshot_name> --description <snapshot_desc>`.
    + "External snapshots" are more complex to use, since although creating them is straightforward manipulating them is not as much. Unfortunately, not only they are more efficient than their internal counterparts, but they are also the only available solution in many circumstances, such as when the VM has multiple disks. [This repository](https://github.com/Yp3rion/external-snapshot-manager) contains a script which can be used to make managing this type of snapshots a bit more user-friendly. 

## Setting up the analysis machine
For the analysis machine, we will start by installing an Ubuntu release; the installation image can be downloaded [here](https://ubuntu.com/download/desktop). The process is very similar to the one followed for pfSense:
1. Create the disk image where the system will be installed with `qemu-img`, e.g. with a size of 60G.
2. Create the VM with `virt-install`, e.g.:
   ```bash
   virt-install \
   --name analysis-machine \
   --memory 4096 \
   --disk <install_img>,device=cdrom,boot_order=1 \
   --disk <hd_img>,bus=virtio,boot_order=2 \
   --boot cdrom \
   --network network=pfsense-net,model=virtio \
   --network network=victim-net,model=virtio \
   --input mouse \
   --input keyboard \
   --graphics spice,mouse_mode=server,clipboard_copypaste=no,filetransfer_enable=no 
   ```
   This time, we assign to the machine 4G RAM since we are going to need it for analysis purposes; moreover, we can notice how the two network interfaces of this machine are attached to the `pfsense-net` and `victim-net` networks, as described in the diagram.  
3. Follow the installation procedure. At the end, don't reboot the VM; instead, open a terminal on the host and gracefully terminate the VM with `virsh shutdown analysis machine`, then from the VM press `Enter` to complete the shutdown. Once the VM has been terminated, eject the `cdrom` device with `virsh change-media analysis-machine <cdrom_dev> --eject` as shown in step 5 for pfSense; finally, restart the VM with `virsh start analysis-machine && remote-viewer spice://localhost:590x &` so that it boots from the hard drive.
4. Now we need to configure the two network interfaces; again, first of all we need to associate the interface names as obtained by running `ip link` within the VM to the virtual network each of them is attached to, so that we can assign the correct addresses to them. An example of the output returned from `ip link` can be seen in the screenshot below:

    <p align="center">
    	<img src="images/ip_link_screenshot.png">
    </p>

    Excluding the loopback interface `lo`, the two network interfaces we need to configure are `ens3` and `ens4`; we can follow the same procedure explained in step 8 for pfSense to learn that `ens3` is the interface connected to the `pfsense-net` network, whereas `ens4` is the one connected to the `victim-net` network. In order to confirm the two interfaces, execute the command `nmtui` and select `Edit a connection`; depending on the interface associated with it, configure each of the two wired connections as shown in the screenshots below:

    <p align="center">
        <img src="images/ens3_config_screenshot.png">
        <img src="images/ens4_config_screenshot.png">
    </p>	
 
5. Since we want the analysis machine to act as a router, we need to have IP forwarding enabled for IPv4; we can do this in a persistent way by editing the `/etc/sysctl.conf` file (`sudo vi /etc/sysctl.conf`) and uncommenting the line `#net.ipv4.ip_forward=1`; the new setting can then be immediately loaded by executing the command `sudo sysctl -p`.
6. This step is a preparation for the following one; we need to free up port 53, which is used by default by `systemd-resolved`, so that we will then be able to use it for a DNS server of our choice. A good tutorial on how to do this can be found [at this link](https://www.linuxuprising.com/2020/07/ubuntu-how-to-free-up-port-53-used-by.html), although in our case for the first step we do not need to touch the `DNS=` value since the DNS server was already configured with `nmtui` to point to 10.0.0.1:53 on our pfSense.
7. Now we can setup a DNS server for our victim machines to point to. We want it to be on the analysis machine because one of the tools we are going to use, the NoPE Proxy extension of Burp Suite, needs to set up a "mock" DNS server in order to make victim machines direct all their traffic to the IP of the analysis machine; in order to make sure that victim machines have connectivity even when not using NoPE Proxy without needing to change their configuration, we will leverage the BIND9 DNS software to create a service on our analysis machine which will act as a “true” DNS server listening on 10.0.1.1:53 when the mock DNS server is down. This can be done as follows:

    1. Install bind9 on the analysis machine with `sudo apt install bind9`
    2. Configure the service by editing the file `/etc/bind/named.conf.options`; we need to:
        + Add the service listening on port 53 of the LAN interface of our firewall as our forwarder by uncommenting the `forwarders` block and replacing 0.0.0.0 with 10.0.0.1;
        + Set the `dnssec-validation` option to `no`, since we are not expecting to receive DNSSEC records from our forwarder;
        + Add the line `listen-on { 10.0.1.1; };` so that the service will actually be reachable from the victims’ network.  
    3. Restart the service with `sudo systemctl restart named` in order to immediately apply the new configuration.

   Notice that the service should be by default enabled to autostart at boot. In order to take it down so that the mock DNS server can be started up in its place it is possible to run the command `sudo systemctl stop named`; then, when needed again, it can be brought back up with `sudo systemctl start named`. 
   
   **NOTE**: It is actually not strictly necessary to install `bind9`; a simpler alternative would be to just set 10.0.0.1, the IP of the LAN interface of our pfSense, as secondary DNS so that the victim machines can simply fall back to it when the "mock" DNS server on the analysis machine is disabled. But this would be too easy... 
8. For now, there is nothing else we need to do on this machine. Take a snapshot with `virsh snapshot-create-as` as shown in step 12 for pfSense (or an external snapshot, depending on your preference).


## Configuring pfSense
Now that we have our pfSense and analysis machines ready, it is time to configure pfSense so that all machines within the lab's network can reach the Internet; later on we will also make sure to prevent them from reaching our own home network. We will configure our pfSense via the web interface, which can be accessed from the analysis machine by opening a browser at https://10.0.0.1; we can login with username "admin" and password "pfsense" (we will be asked to change it later anyways). Disregard the certificate error shown by the browser and proceed anyways; it is triggered by the pfSense presenting a self-signed certificate, but we trust our own VM, right? 
1. Complete the setup wizard; there should be no need to change anything here, apart from the admin password.
2. Go to `Firewall->Aliases` and select `Add`. Create an alias for the 10.0.0.0/8 network as shown in the screenshot below and click `Save`; after returning to the list of aliases, click on `Apply Changes`.

    <p align="center">
        <img src="images/pfsense_lab_alias_screenshot.png">
    </p>	

3. Now we need to provide the pfSense with a route towards the internal network through the 10.0.0.2 interface of the analysis machine; in order to do this, first go to `System->Routing` and select `Add` to add a new gateway, as shown in the screenshot below. Click `Save`, then `Apply changes`.

    <p align="center">
        <img src="images/pfsense_lab_gw_screenshot.png">
    </p>	

    After that, in the `Static Routes` tab, click add to define a new static route. Select 10.0.0.0/8 as destination network and specify the gateway we just created. Save and apply the changes. Now the Windows 10 machine should be able to access https://10.0.0.1 too.
4. Now go to `Firewall->Rules` and select the `LAN` tab. There should be 3 default rules. The IPv6 rule can be disabled/deleted; for now, we will just edit the IPv4 "Default allow LAN to any" rule in order to allow all entire traffic from our LAN network. The only part we need to edit is the `Source` section, where we will replace `LAN net` with `Single host or alias` and then specify the name of the alias we created in step 2 in the field to the right. Save and apply the changes.
5. Now we can finally set up the `tor` gateway on the pfSense. In order to do this, there are several good guides already available on-line, such as [this one](https://catalyst256.medium.com/dark-web-building-a-tor-gateway-7a7dfa45884f); since we have already done all the setup, we can start following the guide from the last paragraphs of step 4, which concern disabling the DNS Resolver service on the pfSense. Nevertheless, our setup will have to differ from what the guide shows in a few aspects:  
   + Everytime the author selects `LAN net` while configuring firewall and port forwarding rules we will instead be selecting `Single host or alias` and then insert the name of the alias we defined in step 1. 
   + When setting up the pass rule to reach port 53 on the firewall we will select as source not the entire lab network, but only the 10.0.0.2 interface of our analysis machine, as this is the only machine that will be allowed to directly communicate with the firewall. 
 
   As previously mentioned, step 4 can consist in setting up a VPN gateway rather than `tor` on the pfSense.  Notice that, due to our network setup, if there is already an active NordVPN client on the host machine the guests should automatically be protected too; knowing how to set up a separate gateway might still be useful though since one may want to use different VPN products or maybe to keep protecting traffic from the lab network even when the host itself is not connected to the VPN. For setting up a NordVPN gateway in particular, there is [a very exhaustive guide](https://support.nordvpn.com/Connectivity/Router/1626958942/pfSense-2-5-Setup-with-NordVPN.htm) describing the process. Only thing to note is that in our case at step 6 of the guide we will leave both `DHCP Registration` and `Static DHCP` unchecked, since we are not using DHCP in the first place.

If all the instructions have been correctly followed now all traffic from within our lab should be protected through TOR (or VPN)! This is a perfect moment to <u>take another snapshot</u>, at least for our pfSense. 

Now there is another very important step left for us, that is securing our home network and also the pfSense and analysis machine themselves; we definitely don't want malware to compromise either of them. But before that, we should start actually adding a few victim machines to our network!  

## Setting up a Windows 10 victim
It is finally time to set up an actual victim machine, i.e. a machine which will be located within the `victim-net` network and where malware will actually be executed. The first victim machine we will add to our lab is a Windows 10 machine (installation image can be downloaded [here](https://www.microsoft.com/en-us/software-download/windows10ISO)).  
1. Create the disk image where the system will be installed using `qemu-img`; in this case we can choose a size of about 80G (or more).
2. Since Windows 10 does not include `virtio` drivers by default, we will need to install them ourselves. The ISO file containing all `virtio` drivers can be downloaded [here](https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md) (select `Stable virtio-win ISO`).
3. Create the VM with `virt-install`, e.g.:
   ```bash
   virt-install \
   --name win10-victim \
   --memory 4096 \
   --disk <install_img>,device=cdrom \
   --disk <virtio_img>,device=cdrom \
   --disk <hd_img>,bus=virtio \
   --boot cdrom \
   --input mouse \
   --input keyboard \
   --network network=victim-net,model=virtio \
   --features kvm_hidden=on \
   --cpu host,-hypervisor \
   --graphics spice,mouse_mode=server,clipboard_copypaste=no,filetransfer_enable=no \
   --os-type=windows \
   --os-variant=win10
   ```
   As it can be noticed, this command is slightly different from the corresponding ones seen for the other two VMs; first, we can notice that the ISO containing `virtio` drivers, `<virtio_img>` has been added as a secondary `cdrom` device; second, we can also notice the `--os-type` and `--os-variant` options, which are not necessary but can help with slightly improving the performance of the VM (they definitely do in this case). Finally, the most interesting ones are the `--features` and `cpu` options: these are used, respectively, to hide the hypervisor's signature in and to disable the hypervisor bit. This is meant as a (partial) solution against some anti-VM tricks employed by malware to guess if it is being analyzed and behave accordingly.
4. Follow the installation procedure as explained [here](https://linuxhint.com/install_virtio_drivers_kvm_qemu_windows_vm/) in order to correctly set up the `virtio` drivers (ignore the part about setting up the VM).
5. Configure the network interface; to do this, type "Ethernet" in the search bar and select `Ethernet settings`, then click on the "Unidentified network" icon and click `Edit` under `IP settings`. Configure IPv4 as shown in the screenshot below. Leave IPv6 off.

    <p align="center">
        <img src="images/win_if_config_screenshot.png">
    </p>	

    Notice how we set the IP of the `ens4` interface of our analysis machine as DNS server; this will be useful since it will allow us to Man-In-The-Middle traffic coming from this machine using `Burp Suite`.

6. Create a snapshot with `virsh snapshot-create-as`.

## Setting up an Android victim 
While Windows malware is probably the most widespread type of malware, it is also cool to be able to study malware made for a very different platform, i.e. Android. Therefore, we are now going to set up another victim machine with an Android OS. The OS of our choice in this case shall be Bliss OS, because there are x86 images available and it just looks cooler than the alternative Android x86. Also, a "nice to have" in Bliss OS is that it has the "Stay awake" developer option enabled by default, which means that the VM will never go in sleep mode; just a minor plus. This having been said, let's now download the latest stable release from [here](https://blissos.org/index.html#download) and proceed with the following steps:
1. As we already know by now, create a disk image to install the system on with `qemu-img`; 20G should be enough for an Android machine.
2. Create the VM with `virt-install`, e.g.:
   ```bash
   virt-install \
   --name android-victim \
   --memory 4096 \
   --disk <install_img>,device=cdrom,boot_order=1 \
   --disk <hd_img>,bus=virtio,boot_order=2 \
   --boot cdrom \
   --input mouse \
   --input keyboard \
   --network network=victim-net,model=virtio \
   --features kvm_hidden=on \
   --cpu host,-hypervisor \
   --graphics spice,mouse_mode=server,clipboard_copypaste=no,filetransfer_enable=no
   ```
3. Follow the instructions which can be found in [this helpful article](https://blog.cyberethical.me/android-malware-analysis-preparation) to install the system (we can start from the section with title "Install Android system"). Notice that although the article is about installing Android x86, the procedure for Bliss OS is exactly the same.
4. Once installation is complete, select "Run Bliss-OS" to boot the newly installed OS; as soon as the OS finishes booting, shutdown the machine by running `virsh shutdown android-victim` from a terminal and clicking on the "Power off" button within the VM.
5. Remove the installation `cdrom` device with `virsh change-media` as we have already seen previously and restart the VM with `virsh start` so that this time it will directly boot from the hard drive.
6. Now we have to set up the virtual WiFi connection. In order to do this, go to `Settings > Network & interneti > Wi-Fi` and turn WiFi on. Then open the `Network details` page for the `VirtWifi` connection and click on `Modify` in order to edit its configuration. In particular, set the `IP settings` option to `Static` and configure the rest as in the following screenshot:

    <p align="center">
        <img src="images/android_virtwifi_screenshot.png">
    </p>	
   
   Just click on `Save`. Internet is all set up too!

With this simple last step, we should have now a fully working Android VM. But it's not enough for us, we want to be able to study whatever application we decide to run on it! We will not do this on the Android machine itself, but on our Ubuntu analysis machine instead; because of this, we now have to set up a working ADP connection over TCP.

### Setting up ADB
This procedure will allow us to use ADB on our analysis machine to gain full control over the Android machine in a simple, comfy way. Among other things, we will need an ADB connection in place in order to use the `frida` dynamic instrumentation toolkit. The steps for setting up ADB are the following:
1. First of all we need, of course, to download the `adb` tool on our analysis machine. It can be downloaded from [this link](https://developer.android.com/studio/releases/platform-tools) as part of the Android SDK Platform Tools. After downloading the compressed folder, simply extract it in any location.
2. Now in order to actually be able to connect to the Android machine over TCP we will need to place the ADB public key of our analysis machine into the list of authorized keys stored at `/data/misc/adb/adb_keys` on the device. In order to do this we will play with the `nc` utility. First, spawn a terminal in the Bliss OS machine and get `root` privileges with `su`, then launch the command `nc -l -p <port> >> /data/misc/adb/adb_keys`, where `<port>` is an arbitrary port we will connect to from the analysis machine. With this command, we are going to append to the `adb_keys` file the content that will be sent from the other machine. On the analysis machine instead, first launch the command `./adb devices` from the folder which was just extracted (this will generate the ADB key pair), then launch `nc 10.0.1.3 <port> < ~/.android/adbkey.pub`, which will send the public key directly into the destination file. After launching the second command, terminate both of them with `Ctrl+C` and then, from the terminal in the Android device, run `chmod 644 /data/misc/adb/adb_keys` so that the `adbd` daemon will be able to open the newly created file.
3. It is now time to specify the port on which ADB will listen in our Android device. From the terminal with `root` privileges, launch the command `setprop service.adb.tcp.port <port>`, where `<port>` is the port we will connect to from the analysis machine (it does not have to be the same used by `nc`).
4. At this point we should be able to simply start the `adbd` daemon with `start adbd` in the Android terminal and then connect from the analysis machine with `./adb connect 10.0.1.3:<port>`!  

Notice that step 3 and 4 will have to be repeated every time the android machine is rebooted; if a way to make these settings persistent across reboot is found, this section will be updated as needed.

### Installing `pyenv` and `frida-tools`
As mentioned in the previous section, one of the tools we will be most interested in using with our Android VM is `frida`, which is a powerful, very cool dynamic instrumentation framework. Let us see which are the steps to install it. 
1. First of all, we will install `pyenv` on the analysis machine, which will allow us to build different versions of python and use them to create separate virtual environments (or "virtualenvs"), each with its own `python` executable and `pip` packages. Virtualenvs are sexy. Be nice people, always use virtualenvs. Setting up `pyenv` is relatively easy: just follow the "Installation" section of the [readme](https://github.com/pyenv/pyenv) and make sure to check out [the automatic installer](https://github.com/pyenv/pyenv-installer), since it is extremely comfortable to use. After completing the installation, place the following lines at the beginning of `/etc/profile`:
   ```bash
   export PYENV_ROOT="$HOME/.pyenv"
   export PATH="$PYENV_ROOT/bin:$PATH"
   eval "$(pyenv init --path)"
   ```
   And the following lines at the end of `~/.bashrc`:
   ```bash
   eval "$(pyenv init -)"
   eval "$(pyenv virtualenv-init -)"
   ```
   Then log out and log back in. Now it should be possible to invoke `pyenv` from the terminal.
2. Once `pyenv` has been installed, install a new Python version with `pyenv install <version_num>` and then create a new virtualenv called `frida` with `pyenv virtualenv <version_num> frida`.
3. Activate the new virtualenv with `pyenv activate frida`, then install the `frida-tools` package with `pip install frida-tools`. 
4. Follow [this guide](https://frida.re/docs/android/) to install `frida-server` on the Android machine; here we will need our ADB connection.

Keep in mind that of course the command `./adb shell "/data/local/tmp/frida-server &"` will have to be launched every time the Android device is rebooted. 

**NOTE**: Unfortunately, it appears that `frida` currently (latest version 15.1.17) has a few issues when tested against both Android x86 (release 9.0-r2) and Bliss OS 11.13 (the version used for this lab). More precisely, using the tool `frida-discover` apparently crashes the target application irrespective of the `frida` version being used; moreover, it seems that attempting to load custom scripts also crashes the target application for `frida` versions 15.1.10 and above. [An issue](https://github.com/frida/frida/issues/2023) was posted on the official repository in order to look for fixes; this guide will be updated accordingly as soon as any improvement is made. In the meantime, the suggestion is to use version 15.1.9 for `frida-server` (any of the 10.x.x versions for `frida-tools` should be compatible with it).

### (Optional) Installing Aurora Store
**Aurora Store** (com.aurora.store) is a nifty tool which makes it possible to download applications from the Google Play Store without needing to actually log in with a Google account. This can be interesting as it provides an easy, centralized way to install analysis targets directly from an official source. 

The Aurora Store APK can be downloaded from [here](https://f-droid.org/en/packages/com.aurora.store/) (the current latest version is 4.1.1); once it has been downloaded, just open it and it will guide you through the necessary steps for installation. After installation, just request an `Anonymous` session at the login step. 

Unfortunately, while building this lab some issues were encountered in trying to use Aurora Store over `tor` (no issue at all with VPN); more precisely, the anonymous login step often failed and no clear explanation as to why this happened was identified, although it seems to be related to issues at the TCP layer. In case a permanent solution to this problem is found, this guide will be updated as needed. In the meantime, there are two possible workarounds:
1. The (somewhat) **smart** workaround, which <u>can only be used after a clean snapshot has been restored</u>, is to temporarily connect the android victim machine to the home network via the `default` virtual network, perform the anonymous login and then disconnect it again. The first step is done by attaching a new network interface to the machine with the command `virsh attach-interface --domain android-victim --type network --source default --model virtio`, whereas in order to disconnect we need to find out the MAC address `<mac_addr>` of the newly added interface so that we can remove the correct one. In order to do this, we will simply run the command `virsh dumpxml android-victim | grep -A 7 "<interface"` and look for the MAC address of the interface whose `source` tag has value `default` for the parameter `network`. Then in order to actually detach the interface we will run the command `virsh detach-interface --domain android-victim --type network --mac <mac_addr>`. Done!
2. The **fun but very inefficient** workaround, which consists in leveraging our h4xx0r skillz to instrument the app with `frida` and make sure that it will automatically retry connecting every time it fails (disclaimer: this is *really* not an efficient approach at all, since it may sometimes take a very long time before actually managing to login). [This repository](https://github.com/Yp3rion/frida-scripts) contains a script, `aurora_store_retry_connection.js`, which does exactly that. How convenient (or not), huh?

Unfortunately (again!!), due to the way Aurora Store works in order to allow for true anonymity, it is currently not possible to arbitrarily set the user location, which means that some geoblocked applications may just not be available through this application. In this case, the only Google-less alternative is to rely on third party stores/repositories such as [APKMirror](https://www.apkmirror.com/), [APKPure](https://apkpure.com/), and others.

Concerning the possibility of using an actual Google account to log in directly to the Play Store, this is of course also possible but presents a couple major inconveniences:
1. It does not really solve the issue of geoblocking, since Google only allows to switch the country used by an account once per year.
2. It requires logging in to a Google account (which is usually strictly tied to a user's identity e.g. through their phone number) on a device which is going to be used to execute potential malware and has internet access. 

Due to this, it may be preferable to use a combination of Aurora Store and third party services.

As a final note, if using Aurora Store APKs will be automatically downloaded and installed on the victim machine, but we also need them on the analysis machine for, well, analysis stuff. One way of pulling the APK files for a given application with package name `<package>` over ADB consists in launching the command `adb shell pm path <package>` in order to obtain the path where the apk is stored `<apk_path>` and then executing `adb pull <apk_path> <dest_path>`, where `<dest_path>` is the local path where we want the APK to end up. Of course, for split APK installations the first command will return multiple paths!

With this, our initial setup for our Android machine has been completed too! It is now time to <u>take another snapshot</u> of both the analysis machine and the Android device at least.

## Setting up a macOS victim 
**Disclaimer:** Executing macOS on non-Apple hardware is a violation of Apple's EULA and lies in a legally gray area: although it should be safe to do if it is not for commercial purposes, it is one's own responsibility to research the matter and be fully aware of the implications of their own actions.

Although malware for macOS is not common, it does occurr and it may be interesting to observe its behavior too; of course, this requires having a macOS victim machine available to run it on. Setting up a macOS VM with `libvirt` is not straightforward, but fortunately for us there are several repositories which can be found on GitHub which facilitate the process; the one which was used for this lab is [OSX-KVM](https://github.com/kholia/OSX-KVM) (cheers to the author and contributors). 

Concerning the installation, the repository's readme provides a very clear guide, which we can follow up to the step where a new `libvirt` domain is defined (<u>do not execute</u> the command `./OpenCore-Boot.sh`). Indeed, before running the command `virsh define macOS.xml`, we want to make a couple additional changes to the XML file:
1. Add the following lines inside the `<domain>` tag:
   ```xml
   <pm>
     <suspend-to-mem enabled='no'/>
   </pm>
   ```
   These are needed because apparently when the guest's power management brings the virtual device in a suspended state, there is no way to bring the device back from the dead apart from resetting it.
2. Add the following lines inside the `<graphics>` tag:
   ```xml
   <image compression='off'/>
   <mouse mode='server'/>
   <clipboard copypaste='no'/>
   <filetransfer enable='no'/>
   ```
3. Inside the `<qemu:commandline>` tag, replace `<qemu:arg value='usb-tablet'/>` with `<qemu:arg value='usb-mouse'/>`. This, along with the previous step, is meant to isolate the guest from the host as much as possible.
4. Add the following lines inside the `<features>` tag:
   ```xml
   <kvm>
     <hidden state='on'/>
   </kvm>
   ```
   As it was already explained above, this step is meant to provide some very limited degree of protection against anti-VM tricks; it does not hurt to have this setting in place, but there are several artifacts that a malware might be looking for, therefore be prepared to look for alternative solutions (e.g. patching the malware binary to avoid anti-VM checks).
5. Inside the `<interface>` tag, replace every occurrence of `"bridge"` with `"network"`, then specify `default` as source network and `virtio` as model type. This will make it so that our macOS machine will be connected to the correct network; notice how we temporarily connect to the `default` network because the OS installation requires an internet connection and it seems that it is not possible to manually configure internet settings from the macOS Recovery.
6. One may also want to change the default values for the `<name>` and `<title>` tags, although it is definitely not necessary. For this lab, they were both set to `macos-victim`.

After all these steps have been performed, it is finally time to define and launch the VM in order to perform the installation; then, the final step will be to set up the network. First of all, shut down the device, launch `virsh edit macos-victim` and inside the `<interface>` tag replace `default` with `victim-net` as source network. Then turn on the VM and from `System Preferences->Network` select the `Ethernet` interface and configure it as shown in the screenshot below; finally, for the DNS server, go to `Advanced...->DNS` and add the entry 10.0.1.1 to the `DNS Servers` list. Click `Ok`, then `Apply` to confirm the new configuration.

<p align="center">
	<img src="images/mac_if_config_screenshot.png">
</p>

As usual, this is the right moment for <u>setting up a snapshot</u> of the newly created machine. Notice, though, that for this machine we have no alternative to using "external" snapshots due to its configuration.


## Setting up a Linux victim
The last victim machine we will set up in this lab will be a Linux machine, in order to make it possible to test ELF malware too. We can use the same installation disk we used for the analysis machine (which is what is done in this guide) or download the installer for any other distro we may be interested in, it should not make a significant difference. The procedure to follow is pretty much the same as for the other machines:
1. Create a disk image with `qemu-img`; a size of 40G should be enough.
2. Create the VM with `virt-install`:
   ```
   virt-install \
   --name ubuntu-victim \
   --memory 4096 \
   --disk <install_img>,device=cdrom,boot_order=1 \
   --disk <hd_img>,bus=virtio,boot_order=2 \
   --boot cdrom \
   --input mouse \
   --input keyboard \
   --network network=victim-net,model=virtio \
   --features kvm_hidden=on \
   --cpu host,-hypervisor \
   --graphics spice,mouse_mode=server,clipboard_copypaste=no,filetransfer_enable=no
   ```
3. At the end of the installation process, shutdown the VM from a terminal on the host and eject the cdrom device.
4. Setup the network with `nmtui` as was shown for the analysis machine. In this case, set `IPv4 CONFIGURATION` to `<Manual>`, add the entry 10.0.1.5/24 to `Addresses`, set `Gateway` to 10.0.1.1 and add the entry 10.0.1.1 to `DNS servers`.

With this, our last victim machine should be <u>ready for a snapshot</u> too.

## Setting up additional victim machines
Of course there is no limit to how many victim machines we can add, apart from the available storage space on our PC's hard drive. Indeed, it is actually best to have as many different victims as possible in order to be able to test malware which may work only in specific environments or on specific platforms (e.g. ELF malware is not going to run natively on Windows machines, or malware meant for Windows XP may not be able to run correctly on a Windows 10 machine); while of course it is not possible to add instructions to setup every possible victim machine, this guide should hopefully give a clear enough idea of how the process works. 


## Installing network analysis tools on the analysis machine
Now we can move on to start setting up tools that we might like to have on our analysis machine. A first couple of tools that we absolutely want to have are `wireshark` (which can be installed from the command line by launching the command `sudo apt install wireshark`) and `Burp Suite`, which can be downloaded from [here](https://portswigger.net/burp/releases/professional-community-2021-12-1?requestededition=community). Since the vanilla version of `Burp Suite` only allows us to intercept HTTP/HTTPS traffic, we will also add the `NoPE Proxy` extension (original GitHub repo [here](https://github.com/summitt/Burp-Non-HTTP-Extension)), which will allow us to intercept traffic on other protocols too.

Since we will be handling all traffic from our victim machines through `Burp Suite`, it might be better for us to launch it and `wireshark` as a dedicated user, so that if anything bad happens the damage will hopefully at least be limited to that user. We will also need to allow `wireshark` to sniff traffic as a non-root user and `Burp Suite` to bind arbitrary ports (including well-known ports) as a non-root user. Let's see how to set all this up.

### Configuring Wireshark
1. While installing the tool, select `Yes` to the prompt asking you if `wireshark` should be able to run as non-root.
2. Create a new user named `analysis` and add it to the `wireshark` group (so that it can be used to sniff traffic) with the command `sudo useradd -G wireshark analysis`
3. Create a home folder for the new user with the following commands:
   ```bash
   sudo mkdir /home/analysis
   sudo chown analysis /home/analysis
   sudo chgrp analysis /home/analysis
   ```
   This will be useful to store config files which may be needed by the tools.
4. Since `wireshark` is a GUI application, we need to allow the `analysis` user to leverage our "main" user's desktop to display the window. In order to do this in a persistent way, we can add the following lines at the end of the file /etc/profile:
   ```bash
   if [ "$DISPLAY" != "" ]
   then
       xhost +local:analysis
   fi
   ```
   Notice that it will be necessary to logout and login again in order for the configuration to be applied.
5. At this point we can simply run `wireshark` as user `analysis` with the command `sudo -u analysis wireshark`.

### Configuring Burp Suite
1. Install the `authbind` utility with `sudo apt install authbind`. We will use this utility to give `Burp Suite` permission to listen on ports we specify.
2. Download and install `Burp Suite`; if this was done via the installer script, by default the main executable will be placed at `~/BurpSuiteCommunity/BurpSuiteCommunity` (assuming the Community edition was installed).

Using `authbind`, we can easily provide and remove non-root access to arbitrary ports to `Burp Suite`. For starters, we will allow the tool to listen to ports 53 (DNS), 80 (HTTP) and 443 (HTTPS) by running the following commands:
```bash
cd /etc/authbind/byport
sudo touch 53 80 443
sudo chown analysis 53 80 443
sudo chgrp analysis 53 80 443
sudo chmod u+x 53 80 443
```
Now we will be able to launch `Burp Suite` as user `analysis` and with the added capabilities via the command `sudo -u analysis authbind --deep ~/BurpSuiteCommunity/BurpSuiteCommunity`. 


### Configuring NoPE Proxy
The NoPE Proxy tool is an amazing extension for Burp which will allow us to use its nice feature set in order to manipulate not only HTTP traffic but rather traffic for (almost) any protocol! Only problem: it is a quite old extension, and unfortunately if one was to use the latest release which can be downloaded from the original repository it would not be able to handle TLS traffic correctly due to certificate validation issues. Because of this, it was necessary to update the original code in order to have this functionality work seamlessly. The updated version can be found [on my own fork of the repo](https://github.com/Yp3rion/nope-proxy); a [pull request](https://github.com/PortSwigger/nope-proxy/pull/1) was also made to the [PortSwigger fork](https://github.com/PortSwigger/nope-proxy). In order to configure it we can perform the following steps:  
1. Install `git` and `maven` with `sudo apt install git maven`.
2. Clone the repository with the updated version of the extension using `git clone https://github.com/Yp3rion/nope-proxy.git`.
3. From the root folder of the cloned repository go inside the `NonHTTPProxy` folder with `cd NonHTTPProxy` and run `mvn clean compile assembly::single`. After the build process is completed, it will be possible to find a folder named `target` under the root folder; the compiled extension that we need to load into `Burp Suite` is the `.jar` file named `NonHTTPProxy-0.0.1-SNAPSHOT-jar-with-dependencies.jar` (yes, it's a pretty long name).
4. Launch `Burp Suite`.
5. In `Burp Suite`, go to the `Extender` tab and select `Add`, then specify the newly created `.jar` file for the `Extension file (.jar):` field. Finally, click `Next` to load the extension. Once it has been loaded, a new `NoPE Proxy` tab should appear in `Burp Suite`.
6. At this point, configuring and using `NoPE Proxy` is really simple; apart from following the README on the GitHub repository, one may also follow [this helpful article](https://medium.com/@juan.tirtayana/intercepting-non-http-request-using-burp-suite-extension-8c264b3c41d1). Notice that in our case we need to have to set the `DNS Response Ip` field to 10.0.1.1, since this is the DNS IP we configured on our victim machine. Do not forget to specify port 53 for the `DNS Listener Port:` field either.
7. Remember that we don't actually need the extension to intercept HTTP and HTTPS traffic, since that is what `Burp Suite` was and is meant for! In order to easily add listeners for ports 80 and 443, click on `Add 80 & 443 to Burp` under the `NoPE Proxy > Server Config` tab. These two listeners will be visible and editable under the `Proxy > Options` tab.
8. If needed, it is possible to save the current configuration by going to `Project > Project options > Save project options`; the saved options will then be restored upon startup by selecting `Load from configuration file` rather than `Use Burp defaults`. 

In order to be able to intercept TLS traffic with this extension we also need to do the following:
1. Go to the `Proxy > Options` tab and select `Import / export CA certificate` under the `Proxy Listeners` tab.
2. Under `Export`, select `Certificate and private key in PKCS#12 keystore`.
3. Save the file under the `/home/analysis` folder with name `burpca.p12`, use "changeit" as password.
4. Move the file inside the installation folder of `Burp Suite`, i.e. `~/BurpSuiteCommunity` in this case; it will probably be necessary to use `sudo` in order to do it, since the file belongs to user `analysis` while the folder belongs to our own user.

Notice that, unfortunately, the `Port Monitor` feature does not appear to work with this setup; this is not a necessary feature by the way, since that is information we can also look up on Wireshark. Nevertheless, in case a solution is found this article will be updated accordingly.

Also notice that (for `tor` users), given our current configuration, only traffic to ports 80 and 443 is allowed through the firewall... If in the future it will be necessary to allow other types of traffic we will need to allow that traffic through the firewall first and foremost (and then also use `authbind` to allow `Burp Suite` to bind the relative ports)! VPN users do not have the firewall limitation but they will also need to add ports to `authbind` as needed.

### Intercepting TLS traffic
In order to have `Burp Suite` and the `NoPE Proxy` actually be able to intercept traffic sent over TLS, we will need our victim machine(s) to trust PortSwigger's own CA certificate, so that they will also automatically trust any certificate signed by it. The certificate can be directly downloaded on the victim machine by opening a browser to https://10.0.1.1:8080, but first we need to create and temporarily enable a listener on that port. In order to do that, go to the `Proxy > Options` tab and click on `Add` under `Proxy Listeners`, then set 8080 for the `Bind to port` field and `Specific address: 10.0.1.1` for the `Bind to address` field. On the victim, click on "CA Certificate" to download it.

In order to install the certificate on Windows 10:
1. Click on the downloaded file to open it.
2. Click on `Install Certificate...`.
3. Select `Local Machine`.
4. Select `Place all certificates in the following store` then pick `Trusted Root Certification Authorities`.
5. Complete the process.

Installing the certificate on Bliss OS (based on Android 9) is not as straightforward, because since Android "Nougat" by default apps only trust system-level CAs; fortunately, [this useful article](https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/) shows how to proceed under the section "Install Burp CA as a system-level trusted CA". Notice that:
1. We do not need to launch the `adb remount` command since our `/system/` partition is already writable.
2. We can `push` the certificate directly to its destination `/system/etc/security/cacerts/`, without needing to drop it to `/sdcard/` first.

For macOS:
1. Click on the downloaded file.
2. Add the certificate to the `System` keychain.
3. In the `Keychain Access` utility, go to `System` and select the `PortSwigger CA` certificate. Double click to open the details window.
4. Under `Trust`, for the field "When using this certificate:" specify "Always Trust".
5. Close the window.

For Linux (Ubuntu 20.04):
1. Download the certificate to `<download_path>`.
2. Convert the certificate to PEM format with `sudo openssl x509 -inform DER -in <download_path> -out <output_path>`. Notice that the output file saved at `<output_path>` <u>must</u> have the extension `.crt`!
3. Set the correct file permissions with `sudo chmod 644 <output_path>`
4. Move the certificate to the folder `/usr/local/share/ca-certificate/` with `sudo mv <output_path> /usr/local/share/ca-certificate/`.
5. Run the command `sudo update-ca-certificates`.

Notice that although the PortSwigger root certificate is now in the trust stores of our victims' OSes, whether it is actually accepted will depend on the specific application on a case-by-case basis; an example is the Firefox browser, which keeps its own trust store rather than using the OS-provided one.

It is probably a good idea to <u>take yet another snapshot</u> of the VMs (at least the analysis machine and any victim machine(s) where PortSwigger's CA certificate has been installed) at this point.

## Securing All The Things

Given that we are dealing with actual malware which is going to be executed inside the victim machines with internet access, we need to be very careful with how we manipulate it. We definitely want to avoid our home network to get infected because of our little experiments, don't we? We will try to protect our home network in two different ways:
1. Preventing victim machines from being able to contact machines in our home network.
2. Preventing victim machines from talking directly with the pfSense: only the analysis machine will be able to talk with it.

Concerning the first point, we can handle it quite easily by adding another rule on the LAN interface of our pfSense; from the pfSense console, first of all go to `Firewall->Aliases` and select `Add`. We can create a catch-all alias to identify all the networks that we don't want to be reached from within the lab's network. The screenshot below shows an example of how this alias could be configured; in this case we intend to prevent attempts to connect to any address in the private IP range 192.168.0.0/16, which is the one that is typically used for home networks.

<p align="center">
    <img src="images/pfsense_protected_alias_screenshot.png">
</p>	

Then go to `Firewall->Rules`, select the `LAN` tab, and add a new rule <u>at the top</u>, defined as shown in the screenshot below. The rule should be immediately below the anti-lockout rule, so that it can effectively block traffic as needed.
    
<p align="center">
    <img src="images/pfsense_rule_config_screenshot.png">
</p>	

Concerning the second point, unfortunately we cannot solve it easily by simply adding another firewall rule directly on the pfSense, because:
1. (For `tor` users) It seems that with port forwarding enabled the firewall will treat packets as if they were originally directed to it and drop them even if that was not the case. 
2. Because of how it is defined, the anti-lockout rule allows any machine in the lab network to connect to the pfSense on ports 80 and 443; this is of course excessive and unnecessary, since it is enough to use the analysis machine to perform administrative tasks!

Therefore, we will instead have to add an equivalent `iptables` rule on our analysis machine, with the command `sudo iptables -A FORWARD -s 10.0.1.0/24 -d 10.0.0.1 -j DROP`. It is worth noting that `iptables` rules are not persistent per se; in order to make it so, we will need to install the package `iptables-persistent` with `sudo apt install iptables-persistent`, then we will be able to save the current IPv4 rules by running the command `sudo iptables-save | sudo tee /etc/iptables/rules.v4`.   

In order to protect as much as possible the analysis machine itself too, we should also disable any unnecessary service listening for connections. As an example, in Ubuntu 20.04 we can find `cups` and `avahi-daemon` enabled by default. In order to prevent them from starting automatically, we should execute the following sets of commands:
```bash
sudo systemctl mask cups 
sudo systemctl disable cups 
sudo systemctl stop cups 
```
and
```bash
sudo systemctl mask avahi-daemon
sudo systemctl disable avahi-daemon
sudo systemctl stop avahi-daemon
```
Notice that the `mask` commands are needed because `disable` only prevents the service from autostarting at boot, but does not prevent it from being started by other services which may "need" it.

As an additional precaution, in the `System > Advanced > Admin Access` tab of the pfSense web application we can also add other controls, e.g. under `Login Protection` we can determine how potential bruteforce attacks on the firewall login credentials are handled. The screenshot below shows a quite paranoid setting, blocking potential attacks (10 is the lowest possible threshold, meaning that false negatives should be very unlikely) for a minimum time of two minutes, with a time of 5 hours having to pass before the waiting duration is reset. 

<p align="center">
    <img src="images/pfsense_login_protection_screenshot.png">
</p>	

Last thing that we should do is to setup traffic limiters so that we can control the amount of bandwidth used by the machines in the virtual network; this is meant mainly to limit the impact of potential DDoS attempts from the malware that we are going to execute inside the victim network. We will define two limiters, one for traffic going out of the lab network (upload) and the other for traffic coming inside it (download). In order to create a new limiter, go to the `Firewall > Traffic Shaper > Limiters` tab and click on `New Limiter`. We will set our Upload limiter to a very small amount, say 250 Kbit/sec and our Download limiter to something like 10 Mbit/sec. The Upload limiter can then be configured as shown in the following screenshot (leave other options to default values):

<p align="center">
    <img src="images/pfsense_upload_limiter_screenshot.png">
</p>	

And the Download limiter:

<p align="center">
    <img src="images/pfsense_download_limiter_screenshot.png">
</p>	 

After both the limiters have been defined, what to do depends on whether we are using `tor` or a VPN. If using `tor`, we will need to define a firewall LAN rule to apply them to; this rule will be a "pass" rule which will catch all TCP traffic with the 10.0.1.0/24 network as source and which is forwarded to port 9040 of the firewall itself to go through TOR. Go to the `Firewall > Rules > LAN` tab and create the new rule by clicking on one of the `Add` buttons (it doesn't matter which one, since we will have to change the position of the rule anyways). The screenshot below shows how the rule should be configured. 

<p align="center">
    <img src="images/pfsense_limiter_rule_screenshot.png">
</p>	 

In order to associate our limiters to this rule, in the `Extra Options > Advanced Options` field click on `Display Advanced` and look for the entry `In / Out pipe`. Select our "Upload" limiter in the first dropdown and the "Download" one in the second, then save and click on `Apply Changes`. That's it!

Notice that this rule has to be <u>immediately above</u> the automatically generated rules related to Port Forwarding, which are the ones with description "NAT". This can be done by dragging the newly created rule in the GUI to the correct position and then saving and clicking on `Apply changes` again.

If using a VPN, we just have to apply the limiters to the single LAN rule we are using, the "Default allow LAN to any" rule; applying them to the rule works in the same way as described above for the `tor` case.

## Transferring data securely
While running our analysis tasks or during the reporting phase, it may be necessary to be able to transfer files from where they were created to a single, centralized destination (which may be the analysis machine, or the host machine itself as an example) in order to facilitate working on them. This should be done with care though, especially when working on analysis results which have to be extracted from victim machines after they were infected with malware. In this section we will consider two types of data transfer:
1. Transfer of data between the victim machines and the analysis machine, i.e. transfer of data internally to the lab network.
2. Transfer of data between the host machine and the analysis machine, i.e. transfer of data in and out of the lab network.


### Transferring data between the victims and the analysis machine
For what concerns transferring data between the machines inside the lab, we can note in the first place that the Android victim already has a way to do so via `adb push` and `adb pull`. For the other victim machines, a simple approach could be to set up SSH servers listening on each of them and then transferring files via `scp`, using the analysis machine as a client. In order to enable the SSH server on each of the victim machines:
+ For macOS: go to `System Preferences->Sharing` and tick `Remote Login`.
+ For Linux (Ubuntu 20.04 distro): execute `sudo apt install openssh-server`. Once installation finishes the service will be already enabled and running. 
+ For Windows 10: go to `Settings->Apps->Apps & features` and click on `Optional features`, then `Add a feature` and select `OpenSSH Server`. After installation, we need to set the service to startup automatically and execute it; in order to do this, go to `Control Panel->System and Security->Administrative Tools` and select `Services`. Then, identify the `OpenSSH SSH Server` service and:
   + To set it so that it starts up automatically, go to `Action->Properties` and set `Startup type` to `Automatic`.
   + To execute it, just click on `Start the service`.

Once this has been done, the victim machines can be normally accessed from the analysis machine over SSH.

### Transferring data to/from the host machine
Exchanging data with the host machine, outside of the lab network, is a bit trickier because of the specific setup we chose to use; indeed, as it is we have substantially no means of direct communication (and this is indeed what we want). What comes to our advantage is that our lab network has internet access, which means that we actually have a convenient (and free!) way to share even large files by leveraging online services such as [WeTransfer](), [SendGB](https://www.sendgb.com/), and several others. Some of these services allow anonymous transfer of files with sizes of up to a few GBs by simply sharing short links which can just be manually typed in the URL bar of any browser. Some, such as SendGB, even allow to password protect the shared files; we are likely not going to share any especially sensitive information anyways, but this is nevertheless a nice to have (notice that one could also just encrypt files locally before sending them, if willing to go to these lengths).

There is also another possible approach, which does require to establish a direct communication channel between the host and the analysis machine, which is clearly riskier (although the analysis machine is not supposed to get infected); such alternative solution is setting up a shared folder between the two. Now, `libvirt` uses the SPICE protocol by default; concerning shared folders, it should also support the `virtiofs` driver as per [the docs](https://libvirt.org/kbase/virtiofs.html). If that approach does not work, one can try using an external `virtiofsd` instance as follows:  
   1. Install `libseccomp-dev`.
   2. Clone [this repository](https://gitlab.com/virtio-fs/qemu).
   3. Inside the root folder of the repository, run `./configure -disable-werror` (else it will refuse to proceed due to warnings), then run `make virtiofsd`. 
   4. Before starting the VM, execute the following command from the root folder of the repository:
      ```bash
      sudo ./virtiofsd -o vhost_user_socket=<socket_file_path> -o source=<shared_folder_path> \
      -o cache=always
      ```  
      Where <shared_folder_path> is the path (on the host) of the folder to be shared. It may be possible to avoid having to invoke `sudo`, but this still needs to be tested; this guide will be updated as needed as soon as a confirmation can be provided to this statement. Also, note that this step will have to be repeated every time the VM has to be started.
   
Once the procedure above has been completed, with the VM still turned off edit the VM configuration with `virsh edit <analysis_VM_name>` as follows:
```xml
<domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>
...
<qemu:commandline>
<qemu:arg value='-chardev'/>
<qemu:arg value='socket,id=char0,path=<socket_file_path>'/>
<qemu:arg value='-device'/>
<qemu:arg value='vhost-user-fs-pci,queue-size=1024,chardev=char0,tag=<mount_tag>'/>
</qemu:commandline>
</domain>
```
Where `<mount_tag>` is the tag that will need to be used <u>from within the VM</u> when mounting the shared folder with the command `mount -t virtiofs <mount_tag> <mount_folder`.  

Obviously, after editing the domain configuration, it would be the case to <u>create another snapshot</u> of the analysis VM.

**NOTE**: It might happen that `apparmor` prevents `libvirt` from getting access to `<socket_file_path>`, thus preventing in turn the VM from starting. In order to avoid this, one can edit the file which is typically stored at `/etc/apparmor.d/libvirt/TEMPLATE.qemu` (on the host) and give read (`r`), write (`w`) and lock (`k`) capabilities over `<socket_file_path>`, similar to the following:
```
profile LIBVIRT_TEMPLATE flags=(attach_disconnected) {
#include <abstractions/libvirt-qemu>
<socket_file_path> rwk,
}

```
It is important that the comma is present, else the file will not be parsed correctly.

## Installing other analysis tools
We are almost ready to start enjoying our lab; the next step is installing a few very useful tools that are definitely going to help us with our experiments. 

**NOTE**: This list is an ongoing effort and most definitely not exhaustive! It will be updated as new cool tools are discovered/tools become outdated. Open to suggestions!

On the analysis machine:
+ [Ghidra](https://ghidra-sre.org/)  
   With: 
   + [FindCrypt](https://github.com/TorgoTorgo/ghidra-findcrypt) extension
   + [ghidra_bridge](https://github.com/justfoxing/ghidra_bridge) utility (this starts an RPC server, run Ghidra as user `analysis`!)
+ [Radare2](https://github.com/radareorg/radare2) (and `pip install r2pipe` in a virtualenv for [scripting with Python](https://r2wiki.readthedocs.io/en/latest/home/radare2-python-scripting/)!)  
   **NOTE**: As of 28/04/2022 the latest version of `r2pipe` is 1.6.5, which seems to have some issues &ndash; such as commands returning sometimes the same output as the previous command &ndash;, therefore it is suggested to use 1.6.4 instead with `pip install r2pipe==1.6.4`.
+ [Yara](https://github.com/VirusTotal/yara)  
   Some rule repositories:  
   + [Yara Rules project](https://github.com/Yara-Rules/rules)
   + [List of major repositories](https://github.com/InQuest/awesome-yara)
+ [Apktool](https://ibotpeaches.github.io/Apktool/)
+ [Intellij IDEA](https://www.jetbrains.com/idea/)
+ [dex2jar](https://github.com/pxb1988/dex2jar)
+ [CyberChef](https://github.com/gchq/CyberChef)
+ The `p7zip-full` package (can be installed via `atp` on Debian/Ubuntu, good for handling compressed archives)

On the Windows 10 victim:
+ [ProcessHacker](https://github.com/processhacker/processhacker)
+ [pestudio](https://www.winitor.com/)
+ [PE-bear](https://hshrzd.wordpress.com/pe-bear/)
+ [Windows Sysinternals Suite](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)
+ [x64dbg](https://x64dbg.com/)
+ [signsrch](http://aluigi.altervista.org/mytoolz.htm)
+ [7-Zip](https://www.7-zip.org/)

On the macOS victim:
+ [Xcode Command Line Tools](https://mac.install.guide/commandlinetools/index.html) (can be installed by attempting to execute any one of them, e.g. `make`, from the terminal)
+ [Tools from Objective-See](https://objective-see.com/) such as ProcessMonitor, FileMonitor, TaskExplorer

On the Linux victim:  
(to be continued)

## Disabling Defender and Automatic Updates on Windows 10
This last step is not strictly mandatory but can help when attempting to observe the behavior of Windows malware which is not extremely recent, as in such cases it is likely that either Defender would attempt to interfere with our analysis or patches would just make it impossible by preventing the malware from exhibiting its behavior. Because of this we will:
1. Permanently disable automatic updates so that we can have more control over which patches are installed and when.
2. Permanently disable Defender (we know that we are executing malware after all...).

Disabling automatic updates is very  easy and can be done by following the instructions presented in [this article](https://www.windowscentral.com/how-stop-updates-installing-automatically-windows-10), section "How to disable automatic updates using Group Policy". Concerning how to disable Defender, it is a little trickier: while this is also done via a Group Policy, before configuring the Group Policy we need to suspend the `MsMpEng.exe` process in order to prevent it from immediately reverting our changes. We can do this with the `ProcessHacker` tool we just installed: launch it, then run a search for the `MsMpEng.exe` process, right-click and select `Suspend`. After this, we can launch the `Edit group policy` tool and navigate to `Computer Configuration->Administrative Templates->Windows Components->Microsoft Defender Antivirus`, then enable the policy `Turn off Windows Defender Antivirus`. When rebooting the VM, navigating to `Windows Security->Virus & threat protection` should show something similar to the image below.

<p align="center">
    <img src="images/win_defender_disabled_screenshot.png">
</p>	 

That's it! If satisfied with the current toolset, one should now <u>create a final snapshot</u> for each VM (the pfSense machine and the Android victim were not modified in the last steps, therefore this should not be necessary for those); these will be the images that we will be using as clean slates to revert to after every experiment. 
